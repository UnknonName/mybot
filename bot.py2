
import os
import json
import sqlite3
import logging
from dotenv import load_dotenv
from uuid import uuid4

from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    MessageHandler,
    CommandHandler,
    ContextTypes,
    filters,
)

from openai import OpenAI

# --------------------------------------
# ENV
# --------------------------------------

load_dotenv()
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

client = OpenAI(api_key=OPENAI_API_KEY)

DB = "memory.db"
TOKEN_LIMIT = 3500

# --------------------------------------
# Logging
# --------------------------------------

logging.basicConfig(
    format="%(asctime)s %(name)s %(levelname)s %(message)s",
    level=logging.INFO
)

# --------------------------------------
# DB init
# --------------------------------------

def init_db():
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("""
        CREATE TABLE IF NOT EXISTS memory (
            user_id TEXT PRIMARY KEY,
            summary TEXT,
            recent TEXT
        )
    """)
    conn.commit()
    conn.close()

def get_mem(user_id):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT summary, recent FROM memory WHERE user_id=?", (str(user_id),))
    row = c.fetchone()
    conn.close()

    if row is None:
        save_mem(user_id, "", [])
        return {"summary": "", "recent": []}

    summary, recent_json = row
    return {
        "summary": summary,
        "recent": json.loads(recent_json)
    }

def save_mem(user_id, summary, recent):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute(
        "REPLACE INTO memory (user_id, summary, recent) VALUES (?, ?, ?)",
        (
            str(user_id),
            summary,
            json.dumps(recent, ensure_ascii=False),
        )
    )
    conn.commit()
    conn.close()

# --------------------------------------
# Personality
# --------------------------------------

PERSONALITY = """
Ты дружелюбный ассистент.
Отвечай понятно и кратко.
Пиши структурировано.
Избегай канцелярита.
"""

# --------------------------------------
# Tokens
# --------------------------------------

def count_tokens(text):
    return len(text.split())

def enforce_token_limit(history):
    total = sum(count_tokens(m["user"]) + count_tokens(m["assistant"]) for m in history)
    while total > TOKEN_LIMIT and len(history) > 1:
        history.pop(0)
        total = sum(count_tokens(m["user"]) + count_tokens(m["assistant"]) for m in history)
    return history

# --------------------------------------
# Streaming response
# --------------------------------------

async def stream_answer(prompt, chat_id, context):
    """
    Отправляет ответ пользователю частями.
    """

    msg = await context.bot.send_message(chat_id, "_Печатаю..._")

    buffer = ""
    last_update = ""

    stream = client.responses.create(
        model="gpt-4o-mini",
        input=prompt,
        stream=True
    )

    async for event in stream:
        if hasattr(event, "delta") and getattr(event.delta, "text", None):
            chunk = event.delta.text
            buffer += chunk

            if buffer != last_update:
                last_update = buffer
                await msg.edit_text(last_update, parse_mode="Markdown")

    return buffer

# --------------------------------------
# Text handler
# --------------------------------------

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    text = update.message.text

    mem = get_mem(user_id)

    mem["recent"].append({"user": text, "assistant": ""})
    mem["recent"] = enforce_token_limit(mem["recent"])

    prompt = (
        f"Память\n{mem['summary']}\n\n"
        f"История сообщений\n{json.dumps(mem['recent'], ensure_ascii=False)}\n\n"
        f"Профиль\n{PERSONALITY}\n\n"
        f"Сообщение пользователя\n{text}"
    )

    answer = await stream_answer(prompt, update.effective_chat.id, context)

    mem["recent"][-1]["assistant"] = answer
    save_mem(user_id, mem["summary"], mem["recent"])

# --------------------------------------
# Commands
# --------------------------------------

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Привет, я здесь.")

async def reset(update: Update, context: ContextTypes.DEFAULT_TYPE):
    save_mem(update.effective_user.id, "", [])
    await update.message.reply_text("Память очищена.")

# --------------------------------------
# Main
# --------------------------------------

def main():
    init_db()

    app = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("reset", reset))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))

    app.run_polling()

if __name__ == "__main__":
    main()

